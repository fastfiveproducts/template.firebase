# AGENTS.md

This file provides guidance to AI tools such as Claude Code (claude.ai/code), Google Gemini CLI, OpenAI Codex CLI, and Cursor when working with code in this project.
Based on Fast Five Products LLC's public AGPL template for Firebase development, version v0.2.7 (updated)


## Build Commands
```bash
# Check schema changes against deployed database
firebase dataconnect:sql:diff

# Regenerate Swift connector code after schema/query/mutation changes
firebase dataconnect:sdk:generate
```

## Architecture

This is a template app of a Firebase backend using Data Connect (PostgreSQL)

### Project Structure
- ./ - this project, firebase Data Connect schema, queries, and mutations
- ../dataconnect-generated/ — Auto-generated Swift connectors (read-only)
- ../{other projects} - client apps


## Schema

Key tables in `dataconnect/schema/schema.gql`:
- `UserAccount` — User profiles keyed by Firebase Auth UID
- `UserDisplayName` — Unique display names (separate table for uniqueness enforcement)
- `UserDemographicProfile` — Append-only demographics (latest row = current)
- `UserAssociation` — Follow/block relationships between users
- `PublicComment` / `PrivateMessage` — User-generated content with reference and status tracking


## Do Not Modify
- `../dataconnect-generated/` — Regenerated by `firebase dataconnect:sdk:generate`
- To change Data Connect behavior, modify `schema.gql`, `queries.gql`, or `mutations.gql` — not the generated connectors


## Query & Mutation Style

**Query naming convention**:
- **"List" queries** — User-facing, safe to call blindly. Always filtered (e.g. display timestamp window) and/or limited. Return minimal columns needed by the client. Examples: `ListPublicComments`, `ListDemographicsGender`.
- **"Get" queries** — Full data retrieval, all columns, scoped only by explicit parameters. No implicit filtering. When called with no parameters, returns everything (a raw dump). Examples: `GetMyUserAccount`, `GetUserAccount`.
- **Search queries** — Use descriptive names like `UserDisplayNameSearch`. Always limited.

**Where-clause style**: Use direct column references (`createUserId: { eq_expr: "auth.uid" }`) instead of FK navigation (`createUser: { id: { eq_expr: "auth.uid" } }`) when filtering by ID. FK navigation is only needed when filtering on a non-ID field of the related table (e.g. `topic: { isPrivate: { eq: true } }`).

**Mutation data style**: Use direct column references (`genderKey: $genderKey`) instead of FK navigation (`gender: { key: $genderKey }`) when setting foreign keys in insert/upsert data blocks. Use raw types (`UUID!`, `String!`) for mutation parameters instead of `_Key` types.

**Upsert audit tracking**: In `_upsert` data blocks, include `updateUserId_expr: "auth.uid"` and `updateTimestamp_expr: "request.time"`. Do not use `createUserId_expr` in upsert data blocks — it gets overwritten on the update path.

**Transaction create-with-association pattern**: Use `@transaction` with `_insert` for both the entity and its association. Reference the server-generated entity ID via `_expr: "response.<alias>.id"` (e.g., `topicId_expr: "response.topicInsert.id"`). Hardcode `associate: true` — you wouldn't create-and-immediately-disassociate.


## Code Review

When asked to "do a code review", follow this process:

### Categories to Evaluate
1. **Bugs** — Logic errors, copy-paste mistakes, typos in code
2. **Security** — Auth gaps, data exposure, input validation, secrets in source control
3. **Error Handling** — Missing edge cases, silent failures
4. **Deprecated APIs** — Use of deprecated Firebase functions
5. **Performance** — Redundant computation, unbounded queries, expensive operations
6. **Style** — Inconsistencies with the rest of the existing codebase
7. **Licensing** — Attribution, copyright headers, commercial risks

### Output Format
Present findings as a numbered table with columns: ID, Category, Priority, Summary, and File(s). Use short IDs (e.g. B1, S1, E1, D1, P1, C1, L1) by category. Prioritize bugs and security issues first.

### Workflow
1. Explore the repo thoroughly, then present the full findings table
2. Discuss each finding with the user — they will decide to fix, close, or defer each one
3. For each fix: edit → build → commit → push
4. After each commit, regenerate the tracking table with updated statuses
5. Use `pbcopy` (with `sed 's/[[:space:]]*$//'`) when asked to copy tables to clipboard

**Table regeneration rule**: Every regenerated table must include all original columns (ID, Category, Priority, Summary, File(s)) plus a Status column. Never abbreviate or drop columns — the table should be self-contained without cross-referencing a previous version.


## Testing

- Manual testing only (no automated test suite)
- Firebase provides a local emulator suite (`firebase emulators:start`) for testing Data Connect queries/mutations against a local PostgreSQL instance without affecting deployed environments. It should generally be used for validating schema migrations and query behavior before deploying.


## Workflow (develop)

Work happens on feature branches off `develop`. Typical flow:

> **Examples for User Initiate**: "Start work on issue 42", "Create a branch for issue #15"

```bash
# 1. Create a feature branch from a GitHub issue
git fetch origin
git checkout develop
git pull origin develop
gh issue develop <issue-number> --base develop --checkout
```

2. Agent: modify schema, queries, or mutations in `dataconnect/`
3. Agent: run `firebase dataconnect:sdk:generate` to check for errors
4. Agent: fix errors and repeat
5. User:  reviews changes and tests with emulator
6. User:  deploys with CLI
7. User:  request commit and push
8. Agent: commit and push the feature branch
9. Agent: create a PR targeting `develop` via `gh pr create --base develop`
10. User: reviews and squash-merges the PR in GitHub
11. Agent: refresh develop locally:

```bash
git checkout develop
git pull origin develop
```

**Code Review**:  User may ask for a Code Review leading to a feature-branch merge, or at any time
**Local branches**: Don't delete local branches after merge — just leave them.


## Release Process (develop to main)

Each commit on `main` represents a published release. Squash all of develop into a single commit on main.

> **Example for User to Initiate**: "Release develop to main as v0.3.1"

```bash
# 1. Ensure develop is current
git checkout develop
git pull origin develop

# 2. Checkout main and pull
git checkout main
git pull origin main

# 3. Squash merge develop into main
git merge --squash develop
git commit -m "$(cat <<'EOF'
Release vX.Y.Z

<release notes body>
EOF
)"
git push origin main

# 4. If step 3 fails with conflicts (common after file renames/moves):
git reset --hard origin/main
git read-tree --reset -u develop
git commit -m "$(cat <<'EOF'
Release vX.Y.Z

<release notes body>
EOF
)"
git push origin main

# 5. Verify content equivalence (should return nothing):
git diff main..develop
```

6. User verifies main with CLI and emulator and deploys as appropriate.


**Commit message**: The first line must be exactly `Release vX.Y.Z` with no suffix — this is the title GitHub displays. After a blank line, add the release notes body. Review `git log main..develop --oneline` and prior release messages on main (`git log main --oneline`) to match the established style. Group changes into categories (e.g. **Feature Area**, **Code Quality**, **Infrastructure**) with concise bullet points summarizing each PR/commit. Also look for previous commit messages that duplicate or cancel each other out and squash them. The body should read as release notes — what changed and why, not individual commit details.

After release, main and develop will have different commit hashes but identical content. GitHub may report main as "behind"/"ahead" of develop — this is expected and should be ignored.


## Common Issues
- **Schema migration conflicts**: Check deployed mutations before removing tables
- **Firebase auth required**: Run `firebase login` if commands fail with auth errors
- **Generated code errors**: Never edit files in `dataconnect-generated/`; fix the source schema/queries instead
