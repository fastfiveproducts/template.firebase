#
#  mutations.gql
#
#  Created by Pete Maiser, Fast Five Products LLC.
#      Template v0.2.x — Fast Five Products LLC's public AGPL template.
#
#  Copyright © 2025, 2026 Fast Five Products LLC. All rights reserved.
#
#  This file is part of a project licensed under the GNU Affero General Public License v3.0.
#  See the LICENSE file at the root of this repository for full terms.
#
#  An exception applies: Fast Five Products LLC retains the right to use this code and
#  derivative works in proprietary software without being subject to the AGPL terms.
#  See LICENSE-EXCEPTIONS.md for details.
#
#  For licensing inquiries, contact: licenses@fastfiveproducts.llc
#

###################################################################
# User

mutation CreateUserDisplayName(
    $displayNameText: String!
) @auth(level: USER) @transaction {

    # Step 1: Check if display name already exists
    # an insert will also be prevented if the user is already hogging 5 displayNames
    query
    @check( expr: "response.query.displayNamesForUser.size() < 6 && response.query.displayNamesMatchingText.size() == 0",
            message: "That display name already exists, or you have already have too many display names.  Please choose another."
    ) {
        displayNamesForUser: userDisplayNames(
            where: { createUserId: { eq_expr: "auth.uid" } }
        ) {
            text
        }

        displayNamesMatchingText: userDisplayNames(
            where: { text: { eq: $displayNameText } }
        ) {
            text
        }
    }

    # Step 2: Insert new display name
    userDisplayName_insert(
        data: {
            text: $displayNameText
            createUserId_expr: "auth.uid"
        }
    )
}

mutation CreateUserAccount(
    $createDeviceIdentifierstamp: String!
    $createDeviceTimestamp: String!
    $displayNameText: String!
    $displayNameTextLower: String!
    $photoUrl: String!
) @auth(level: USER) {
    userAccount_insert(
        data: {
            id_expr: "auth.uid"
            createDeviceIdentifierstamp: $createDeviceIdentifierstamp
            createDeviceTimestamp: $createDeviceTimestamp
            displayNameText: $displayNameText
            displayNameTextLower: $displayNameTextLower
            photoUrl: $photoUrl
        }
    )
}

mutation UpdateUserAccountDisplayName(
    $updateDeviceIdentifierstamp: String!
    $updateDeviceTimestamp: String!
    $displayNameText: String!
    $displayNameTextLower: String!
) @auth(level: USER) @transaction {
#) @auth(level: USER_EMAIL_VERIFIED) @transaction {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.

    # Step 1: make sure the user already 'owns' this Display Name
    query @check(
        expr: "response.query.name.createUser.id == auth.uid"
        message: "You don't own this display name. Please pick another."
    ) {
        name: userDisplayName(key: { text: $displayNameText }) {
            text
            createUser { id }
        }
    }

    # Step 2: Update Display Name, to keep track of the set timestamp
    userDisplayName_update(
        key: { text: $displayNameText }
        data: {
            setTimestamp_expr: "request.time"
            setDeviceIdentifierstamp: $updateDeviceIdentifierstamp
            setDeviceTimestamp: $updateDeviceTimestamp
        }
    )

    # Step 3: Update User Account
    userAccount_update(id_expr: "auth.uid",
        data: {
            updateTimestamp_expr: "request.time"
            updateDeviceIdentifierstamp: $updateDeviceIdentifierstamp
            updateDeviceTimestamp: $updateDeviceTimestamp
            displayNameText: $displayNameText
            displayNameTextLower: $displayNameTextLower
        }
    )
}

mutation UpdateUserAccountProfile(
    $updateDeviceIdentifierstamp: String!
    $updateDeviceTimestamp: String!
    $photoUrl: String!
    # add other fields as needed
) @auth(level: USER) {
#) @auth(level: USER_EMAIL_VERIFIED) {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.
    userAccount_update(id_expr: "auth.uid"
        data: {
            updateTimestamp_expr: "request.time"
            updateDeviceIdentifierstamp: $updateDeviceIdentifierstamp
            updateDeviceTimestamp: $updateDeviceTimestamp
            photoUrl: $photoUrl
            # add other fields as needed
        }
    )
}


###################################################################
# User Demographic Profile
# A User Demographic Profile for a particular user can be changed
# by inserting a new row.

mutation CreateUserDemographicProfile(
    $createDeviceIdentifierstamp: String!
    $createDeviceTimestamp: String!
    $genderKey: String!
    $generationKey: String!
    $regionKey: String!
    $urbanicityKey: String!
    $politicalKey: String!
) @auth(level: USER) {
  userDemographicProfile_insert(
    data: {
        createUserId_expr: "auth.uid"
        createDeviceIdentifierstamp: $createDeviceIdentifierstamp
        createDeviceTimestamp: $createDeviceTimestamp
        genderKey: $genderKey
        generationKey: $generationKey
        regionKey: $regionKey
        urbanicityKey: $urbanicityKey
        politicalKey: $politicalKey
    }
  )
}


###################################################################
# Cross-User Relationships
# User Relationships can be changed by inserting a new row.

mutation CreateUserAssociation(
    $associateUserId: String!
    $associateUserDisplayNameText: String!
    $createDeviceIdentifierstamp: String!
    $createDeviceTimestamp: String!
    $follow: Boolean
    $block: Boolean
    $autoSharePrivateContent: Boolean
) @auth(level: USER) @transaction {
#) @auth(level: USER_EMAIL_VERIFIED) @transaction {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.

    # Prevent self-association and verify target user exists
    query @check(
        expr: "response.query.target.id != auth.uid"
        message: "You cannot follow or block yourself."
    ) {
        target: userAccount(id: $associateUserId) { id }
    }

  userAssociation_insert(
    data: {
        createUserId_expr: "auth.uid"
        associateUserId: $associateUserId
        associateUserDisplayNameText: $associateUserDisplayNameText
        createDeviceIdentifierstamp: $createDeviceIdentifierstamp
        createDeviceTimestamp: $createDeviceTimestamp
        follow: $follow
        block: $block
        autoSharePrivateContent: $autoSharePrivateContent
    }
  )
}


###################################################################
# User Comments, User Messages

mutation CreatePublicComment(
    $toUserId: String!
    $toUserDisplayNameText: String!
    $createDeviceIdentifierstamp: String!
    $createDeviceTimestamp: String!
    $title: String!
    $content: String!
) @auth(level: USER) {
#) @auth(level: USER_EMAIL_VERIFIED) {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.
    publicComment_insert(
        data: {
            createUserId_expr: "auth.uid"
            toUserId: $toUserId
            toUserDisplayNameText: $toUserDisplayNameText
            createDeviceIdentifierstamp: $createDeviceIdentifierstamp
            createDeviceTimestamp: $createDeviceTimestamp
            title: $title
            content: $content
        }
    )
}

mutation CreatePrivateMessage(
    $toUserId: String!
    $toUserDisplayNameText: String!
    $createDeviceIdentifierstamp: String!
    $createDeviceTimestamp: String!
    $title: String!
    $content: String!
) @auth(level: USER) {
#) @auth(level: USER_EMAIL_VERIFIED) {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.
    privateMessage_insert(
        data: {
            createUserId_expr: "auth.uid"
            toUserId: $toUserId
            toUserDisplayNameText: $toUserDisplayNameText
            createDeviceIdentifierstamp: $createDeviceIdentifierstamp
            createDeviceTimestamp: $createDeviceTimestamp
            title: $title
            content: $content
        }
    )
}

mutation CreatePublicCommentReference(
    $publicCommentId: UUID!
    $referenceId: UUID!
) @auth(level: USER) {
#) @auth(level: USER_EMAIL_VERIFIED) {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.
    publicCommentReference_insert(
        data: {
            publicCommentId: $publicCommentId
            referenceId: $referenceId
            createUserId_expr: "auth.uid"
        }
    )
}

mutation CreatePrivateMessageReference(
    $privateMessageId: UUID!
    $referenceId: UUID!
) @auth(level: USER) @transaction {
#) @auth(level: USER_EMAIL_VERIFIED) @transaction {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.

    # Verify the caller is the sender or recipient of the message
    query @check(
        expr: "response.query.msg.createUserId == auth.uid || response.query.msg.toUserId == auth.uid"
        message: "You can only create references for messages you sent or received."
    ) {
        msg: privateMessage(id: $privateMessageId) {
            createUserId
            toUserId
        }
    }

    privateMessageReference_insert(
        data: {
            privateMessageId: $privateMessageId
            referenceId: $referenceId
            createUserId_expr: "auth.uid"
        }
    )
}

mutation CreatePrivateMessageStatus(
    $privateMessageId: UUID!
    $status: String!
) @auth(level: USER) @transaction {
#) @auth(level: USER_EMAIL_VERIFIED) @transaction {
# Production apps should usually use USER_EMAIL_VERIFIED to require
# email verification before allowing this action.

    # Verify the caller is the sender or recipient of the message
    query @check(
        expr: "response.query.msg.createUserId == auth.uid || response.query.msg.toUserId == auth.uid"
        message: "You can only set status on messages you sent or received."
    ) {
        msg: privateMessage(id: $privateMessageId) {
            createUserId
            toUserId
        }
    }

    privateMessageStatus_insert(
        data: {
            privateMessageId: $privateMessageId
            createUserId_expr: "auth.uid"
            status: $status
        }
    )
}
