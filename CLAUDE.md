# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this project.
It is part of Fast Five Products LLC's public AGPL template for Firebase development, version v0.2.7 (updated)


## Build Commands
```bash
# Check schema changes against deployed database
firebase dataconnect:sql:diff

# Regenerate Swift connector code after schema/query/mutation changes
firebase dataconnect:sdk:generate
```

## Architecture

This is a template app of a Firebase backend using Data Connect (PostgreSQL)

### Project Structure
- ./ - this project, firebase Data Connect schema, queries, and mutations
- ../dataconnect-generated/ — Auto-generated Swift connectors (read-only)
- ../{other projects} - client apps


## Schema

Key tables in `dataconnect/schema/schema.gql`:
- `UserAccount` — User profiles keyed by Firebase Auth UID
- `UserDisplayName` — Unique display names (separate table for uniqueness enforcement)
- `UserDemographicProfile` — Append-only demographics (latest row = current)
- `UserAssociation` — Follow/block relationships between users
- `PublicComment` / `PrivateMessage` — User-generated content with reference and status tracking


## Do Not Modify
- `../dataconnect-generated/` — Regenerated by `firebase dataconnect:sdk:generate`
- To change Data Connect behavior, modify `schema.gql`, `queries.gql`, or `mutations.gql` — not the generated connectors


## Code Review

When asked to "do a code review", follow this process:

### Categories to Evaluate
1. **Bugs** — Logic errors, copy-paste mistakes, typos in code
2. **Security** — Auth gaps, data exposure, input validation, secrets in source control
3. **Error Handling** — Unhandled throws, force unwraps, silent failures, missing edge cases
4. **Deprecated APIs** — Use of deprecated Firebase functions
5. **Performance** — Redundant computation, missing caching, unbounded queries, expensive operations
6. **Style** — Inconsistencies with the rest of the existing codebase
7. **Licensing** — Attribution, copyright headers, commercial risks

### Output Format
Present findings as a numbered table with columns: ID, Category, Priority, Summary, and File(s). Use short IDs (e.g. B1, S1, E1, D1, P1, C1, L1) by category. Prioritize bugs and security issues first.

### Workflow
1. Explore the repo thoroughly, then present the full findings table
2. Discuss each finding with the user — they will decide to fix, close, or defer each one
3. For each fix: edit → build → commit → push
4. After each commit, regenerate the tracking table with updated statuses
5. Use `pbcopy` (with `sed 's/[[:space:]]*$//'`) when asked to copy tables to clipboard


## Testing

- Manual testing only (no automated test suite)
- Firebase provides a local emulator suite (`firebase emulators:start`) for testing Data Connect queries/mutations against a local PostgreSQL instance without affecting deployed environments. It should generally be used for validating schema migrations and query behavior before deploying.


## Workflow (develop)

Work happens on feature branches off `develop`. Typical flow:

> **Examples for User Initiate**: "Start work on issue 42", "Create a branch for issue #15"

```bash
# 1. Create a feature branch from a GitHub issue
git fetch origin
git checkout develop
git pull origin develop
gh issue develop <issue-number> --base develop --checkout
```

2. Claude: modify schema, queries, or mutations in `dataconnect/`
3. Claude: run `firebase dataconnect:sdk:generate` to check for errors
4. Claude: fix errors and repeat
5. User:   reviews changes and tests with emulator
6. User:   deploys with CLI
7. User:   request commit and push
9. Claude: commit and push the feature branch
10. Claude: create a PR targeting `develop` via `gh pr create --base develop`
11. User: reviews and squash-merges the PR in GitHub
12. Claude: refresh develop locally:

```bash
git checkout develop
git pull origin develop
```

**Code Review**:  User may ask for a Code Review leading to a feature-branch merge, or at any time
**Local branches**: Don't delete local branches after merge — just leave them.


## Release Process (develop to main)

Each commit on `main` represents a published release. Squash all of develop into a single commit on main.

> **Example for User to Initiate**: "Release develop to main as 0.2.7"

```bash
# 1. Ensure develop is current
git checkout develop
git pull origin develop

# 2. Checkout main and pull
git checkout main
git pull origin main

# 3. Squash merge develop into main
git merge --squash develop
git commit -m "Release vX.Y.Z – <summary>"
git push origin main

# 4. If step 3 fails with conflicts (common after file renames/moves):
git reset --hard origin/main
git read-tree --reset -u develop
git commit -m "Release vX.Y.Z – <summary>"
git push origin main

# 5. Verify content equivalence (should return nothing):
git diff main..develop
```

6. User verifies main with CLI and emulator and deploys as appropriate.


**Commit message**: Review `git log main..develop --oneline` and prior release messages on main (`git log main --oneline`) to match the established style. Group changes into categories (e.g. **Feature Area**, **Code Quality**, **Infrastructure**) with concise bullet points summarizing each PR/commit. Also look for previous commit messages that duplicate or cancel each other out and squash them. The message should read as release notes — what changed and why, not individual commit details.

After release, main and develop will have different commit hashes but identical content. GitHub may report main as "behind"/"ahead" of develop — this is expected and should be ignored.


## Common Issues
- **Schema migration conflicts**: Check deployed mutations before removing tables
- **Firebase auth required**: Run `firebase login` if commands fail with auth errors
- **Generated code errors**: Never edit files in `dataconnect-generated/`; fix the source schema/queries instead
